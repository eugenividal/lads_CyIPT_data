---
title: "Test file"
author: "Eugeni Vidal"
date: "01/10/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Load libraries
library(sf)
library(tidyverse)
library(tmap)
```

## Introduction
  
This is the script to prepare the **CyIPT** data for the paper "Inequalities in cycling participation in England". Four potential indicators at the local authority level are created using this dataset: 

(1) km cycle-friendly infrastructure/km2, 
(2) cyclability index, 
(3) average volume of traffic/cycling flow, and 
(4) Quietness.

The first indicator can be divided into 3: km of cycle tracks/km2, km of cycle lanes/km2, and km of quiet streets/km2. The cyclability index is calculated giving different weight to each type of road in which cycling is allowed. The average volume of traffic is weighted by the flow of cyclists are expected in a future escenario. Quietness is a measure calculated by the cycle street project https://www.cyclestreets.net/help/journey/howitworks/.

## Data preparation

### Load CyIPT and lads dataset for England

```{r, eval=FALSE}
# # Load the data - once, so don't re run multiple times. To create the original file replace infras_test and zones_leeds by infras and lads repsectively.
#
# ## Load infras data
# infras = readRDS("Data/ways_all.Rds")
# 
# ## Filter only leeds
# Leeds <- lads %>%
#   filter(lad17nm=="Leeds")
# infras_test <- infras[Leeds, ]
# 
# # save test data - don't rerun
# saveRDS(infras_test, "Data/infras_test.Rds")
```

```{r}
# Load infras test
infras_test = readRDS("Data/infras_test.Rds")

# Load Leeds zones
zones_leeds <- pct::get_pct_zones(region = "west-yorkshire") %>% st_transform(27700)
zones_leeds <- zones_leeds %>% 
  filter(lad_name == "Leeds") %>% 
  select(geometry)
zones_leeds$st_areashape <- st_area(zones_leeds) # add area

# test calculating length of cycleway in zones across leeds
zones_leeds$length_all = aggregate(infras_test["length_m"], zones_leeds, FUN = sum)$length_m
infras_test$length_cycleway = (infras_test$highway == "cycleway") * infras_test$length_m
zones_leeds$length_cycleway = aggregate(infras_test["length_cycleway"], zones_leeds, FUN = sum)$length_cycleway

plot(zones_leeds["length_cycleway"])
plot(infras_test %>% filter(highway == "cycleway"))
```

### Infrastructure per lad

```{r}
# Extract categories of infrastructure datasets based on https://wiki.openstreetmap.org/wiki/Bicycle#cite_note-anyroad-1. 
## Extract cycleways highway dataset
i_cycleway = filter(infras_test, highway == "cycleway")
## Extract cycleways left or right dataset
i_left_cycleway = filter(infras_test, cycleway.left!= "no" & highway !="cycleway")
i_right_cycleway = filter(infras_test, cycleway.right!= "no" & highway !="cycleway") 
## Extract living streets dataset
i_living_street = filter(infras_test, highway == "living_street" & cycleway.right == "no" & cycleway.left == "no")
## Extract Shared Path dataset
i_shared_path = filter(infras_test, roadtype == "Shared Path" & cycleway.right == "no" & cycleway.left == "no")
## Extract 20mph zones dataset
i_20mph = filter(infras_test, (highway != "cycleway" & highway != "living_street" & roadtype != "Shared Path" & cycleway.left == "no" & cycleway.right == "no") &  maxspeed <= "20")
```

```{r}
# Aggregate infrastructure variables to lads
# lads$length_infras = aggregate(infras["length_m"], lads, FUN = sum)$length_m
# Aggregate cycleways highway
zones_leeds$length_cycleway = aggregate(i_cycleway["length_m"], zones_leeds, FUN = sum)$length_m
## Replace NA by 0
zones_leeds$length_cycleway[is.na(zones_leeds$length_cycleway)] = 0
# Aggregate cycleways left or right
zones_leeds$length_r_cycleway = aggregate(i_right_cycleway["length_m"], zones_leeds, FUN = sum)$length_m
zones_leeds$length_l_cycleway = aggregate(i_left_cycleway["length_m"], zones_leeds, FUN = sum)$length_m
## Replace NA by 0
zones_leeds$length_r_cycleway[is.na(zones_leeds$length_r_cycleway)] = 0
zones_leeds$length_l_cycleway[is.na(zones_leeds$length_l_cycleway)] = 0
# Aggregate length living streets
zones_leeds$length_living_streets = aggregate(i_living_street["length_m"], zones_leeds, FUN = sum)$length_m
## Replace NA by 0
zones_leeds$length_living_streets[is.na(zones_leeds$length_living_streets)] = 0
# Aggregate shared paths
zones_leeds$length_shared_paths = aggregate(i_shared_path["length_m"], zones_leeds, FUN = sum)$length_m
## Replace NA by 0
zones_leeds$length_shared_paths[is.na(zones_leeds$length_shared_paths)] = 0
# Aggregate length 20mph
zones_leeds$length_20mph = aggregate(i_20mph["length_m"], zones_leeds, FUN = sum)$length_m
## Replace NA by 0
zones_leeds$length_20mph[is.na(zones_leeds$length_20mph)] = 0
```

```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
# Create three general categories of cycle-friendly infrastructure
## Cycle tracks - Roads dedicated to cyclists on separate right of way
zones_leeds$length_cycle_tracks <- zones_leeds$length_cycleway + zones_leeds$length_shared_paths
## Cycle lanes - Lanes marked on a portion of a carriageway designated for cyclist use
zones_leeds$length_cycle_lanes <- zones_leeds$length_r_cycleway + zones_leeds$length_l_cycleway
## Quiet streets - living streets or roads max speed <= 20 mph
zones_leeds$length_quiet_streets <- zones_leeds$length_20mph + zones_leeds$length_living_streets
```

```{r message=FALSE, warning=FALSE, cache=FALSE, include=FALSE, paged.print=FALSE}
# Create infrastructure indicators
## Convert area m^2 to km^2
zones_leeds$km2 <- zones_leeds$st_areashape/1000000
## Cycling segregated infrastructure per area
zones_leeds$cycle_tracks_km2 = (zones_leeds$length_cycle_tracks/1000)/(zones_leeds$km2)
## Cycling non segregated infrastructure per area
zones_leeds$cycle_lanes_km2 = (zones_leeds$length_cycle_lanes/1000)/(zones_leeds$km2)
## Quiet streets per area
zones_leeds$quiet_streets_km2 = (zones_leeds$length_quiet_streets/1000)/(zones_leeds$km2)
## Total cycle-friendly infrastructure per area.
zones_leeds$total_cycle_friendly_inf_km2 = ((zones_leeds$length_cycle_tracks + zones_leeds$length_cycle_lanes + zones_leeds$length_quiet_streets)/1000)/(zones_leeds$km2)
```

### Cyclability

```{r, include = FALSE} 
# Create the bikeability weights from dodgr package
weighting_profiles = dodgr::weighting_profiles$weighting_profiles
bike_profile = weighting_profiles %>%
  filter(name == "bicycle") %>%
  select(highway = way, value)
#bike_profile
## Join this file with the bikeability weights
infras_test = left_join(infras_test, bike_profile)
```

```{r}
# Aggregate cyclability indicator
zones_leeds$cyclability = aggregate(infras_test["value"], zones_leeds, na.rm = TRUE, FUN = mean)$value
```

### Volume of traffic

```{r}
infras_test$volume = infras_test$aadt * infras_test$pct.census
# Aggregate cyclability indicator
zones_leeds$volume = aggregate(infras_test["volume"], zones_leeds, na.rm = TRUE, FUN = mean)$volume
```

### Quietness

```{r}
# Aggregate cyclability indicator
zones_leeds$quietness = aggregate(infras_test["quietness"], zones_leeds, na.rm = TRUE, FUN = mean)$quietness
```

```{r}
# save test data
saveRDS(zones_leeds, "Data/zones_leeds.Rds")
```

## Visualisation variables

### Maps

```{r}
tmap_mode("view")
# Map km cycle friendly infras/km^2
p1 <- tm_shape(zones_leeds) +
  tm_fill("total_cycle_friendly_inf_km2", title="km cycle friendly infras/km2", breaks=c(seq(0, 10, by=2.5), Inf), palette="Blues")
```

```{r}
tmap_mode("view")
# Map index of cycleability
p2 <- tm_shape(zones_leeds) +
  tm_fill("cyclability", title="Cycleability index", palette="Greens")
```

```{r}
tmap_mode("view")
# Map volume of traffic
p3 <- tm_shape(zones_leeds) +
  tm_fill("volume", title="Volume of traffic", palette="Oranges")
```

```{r}
tmap_mode("view")
# Map quietness
p4 <- tm_shape(zones_leeds) +
  tm_fill("quietness", title="Quietness (%)", palette="Reds")
```

```{r}
current.mode <- tmap_mode("plot")
tmap_arrange(p1, p2, p3, p4)
tmap_mode(current.mode) 
```

### Data distribution

- Data visualisation. The total_cycle_friendly_inf_km2 data is very skewed to the left. However, the cyclability index looks normalised. 

```{r}
# Infrastructure data very skezed to the left. 
hist(zones_leeds$total_cycle_friendly_inf_km2)
#hist(log(lads$total_cycle_friendly_inf_km2))
```

```{r}
hist(zones_leeds$cyclability)
```

```{r}
hist(zones_leeds$volume)
```

```{r}
hist(zones_leeds$quietness)
```

The skeweness of the first indicator is because cycling infrastructure is very low and tend to be concentrated in urban areas. But it might be also because OSM collaborations are higher in urban than in rural areas. How can we check this? One solution could be to analyse only specific urban areas - those in where the level of contributions is enough to make the data reliable.

The cyclability index data is normalised because it takes into account all types of infrastructure, not only cycle-friendly infrastructure. It looks much more reliable.

# Things left to solve

- Simplify code - add just three categories of infrastructure

- Volume traffic variable, use function weighted.mean() to weight *aadt* per *dutch scenario*.